{
  
    
        "post0": {
            "title": "The Mathematics of Drilling Intercepts",
            "content": ". from google.colab import drive drive.mount(&#39;/content/drive&#39;) . Mounted at /content/drive . import pandas as pd intercepts = pd.read_excel(&#39;drive/My Drive/Projects/posts/data/Great_Bear/lp_drill_hole_composites_all.xlsx&#39;) . What are intercepts? This will be clearer when considering a single hole: . dh_101 = intercepts[intercepts[&#39;Drill Hole&#39;] == &#39;BR-101&#39;] dh_101 . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) . 398 BR-101 | NaN | 108.30 | 108.80 | 0.50 | 7.47 | . 399 BR-101 | and | 120.30 | 133.00 | 12.70 | 0.51 | . 400 BR-101 | including | 127.85 | 128.85 | 1.00 | 2.42 | . 401 BR-101 | and | 143.00 | 160.00 | 17.00 | 0.17 | . 402 BR-101 | and | 169.85 | 233.10 | 63.25 | 3.61 | . 403 BR-101 | including | 169.85 | 222.00 | 52.15 | 4.24 | . 404 BR-101 | and including | 195.00 | 198.00 | 3.00 | 42.70 | . 405 BR-101 | and including | 195.50 | 197.50 | 2.00 | 61.73 | . 406 BR-101 | and including | 197.00 | 197.50 | 0.50 | 118.00 | . 407 BR-101 | and including | 211.90 | 222.00 | 10.10 | 5.91 | . 408 BR-101 | and including | 211.90 | 221.00 | 9.10 | 6.50 | . 409 BR-101 | and including | 211.90 | 217.00 | 5.10 | 7.68 | . 410 BR-101 | and including | 212.45 | 218.00 | 5.55 | 7.82 | . 411 BR-101 | and including | 216.00 | 218.00 | 2.00 | 8.21 | . Many experienced mining investors immediately recognize these grades as very high, but the rest of us might need to rely on statistics, since we don&#39;t have the benefit of many years&#39; experience with drilling results. . Of course it is first necessary to determine the true assay values for each separate interval from top to bottom. As described above, the subinterval gold is INCLUDED in the parent interval calculatoin. So we can&#39;t just use the Gold (g/t) field directly, since intercepts are reported with &quot;highlights&quot;, or higher grade sections within the longer interval. . Sometimes this convention is used unethically to suggest larger intervals of enrichment than truly exist. This is called &quot;grade smearing&quot; and the method of residual grade calculation applied here will detect any such attempt to disguise poor results. . dh_101[&#39;Record&#39;] = dh_101.index . /usr/local/lib/python3.6/dist-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . dh_101 . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) Record . 398 BR-101 | NaN | 108.30 | 108.80 | 0.50 | 7.47 | 398 | . 399 BR-101 | and | 120.30 | 133.00 | 12.70 | 0.51 | 399 | . 400 BR-101 | including | 127.85 | 128.85 | 1.00 | 2.42 | 400 | . 401 BR-101 | and | 143.00 | 160.00 | 17.00 | 0.17 | 401 | . 402 BR-101 | and | 169.85 | 233.10 | 63.25 | 3.61 | 402 | . 403 BR-101 | including | 169.85 | 222.00 | 52.15 | 4.24 | 403 | . 404 BR-101 | and including | 195.00 | 198.00 | 3.00 | 42.70 | 404 | . 405 BR-101 | and including | 195.50 | 197.50 | 2.00 | 61.73 | 405 | . 406 BR-101 | and including | 197.00 | 197.50 | 0.50 | 118.00 | 406 | . 407 BR-101 | and including | 211.90 | 222.00 | 10.10 | 5.91 | 407 | . 408 BR-101 | and including | 211.90 | 221.00 | 9.10 | 6.50 | 408 | . 409 BR-101 | and including | 211.90 | 217.00 | 5.10 | 7.68 | 409 | . 410 BR-101 | and including | 212.45 | 218.00 | 5.55 | 7.82 | 410 | . 411 BR-101 | and including | 216.00 | 218.00 | 2.00 | 8.21 | 411 | . At first it may seem like the correct interpretation of these intervals is to imagine them intervals stacked on top of one another, but this is very misleading. We can easily visualize this to see the error: . import altair as alt y_axis = alt.Axis( title=&#39;Intercept ID&#39;, offset=5, ticks=False, domain=False ) alt.Chart(dh_101).mark_bar().encode( alt.X(&#39;From (m):Q&#39;, scale=alt.Scale(zero=False)), x2=&#39;To (m):Q&#39;, y=alt.Y(&#39;Drill Hole:N&#39;, axis=y_axis), color=alt.Color(&#39;Gold (g/t):Q&#39;, scale=alt.Scale(scheme=&quot;inferno&quot;)), tooltip=[ alt.Tooltip(&#39;Width (m):Q&#39;, title=&#39;Width&#39;), alt.Tooltip(&#39;Gold (g/t):Q&#39;, title=&#39;Gold Grade&#39;) ] ).properties(width=800, height=100).configure(background=&#39;#D9E9F0&#39;) . Example: | . This is actually a fairly complicated question. | Parent intervals can have no child intervals, a single child interval, or several child intervals. | Child intervals themselves can have no child intervals, a single child interval, or several child intervals | We only have the total grade, INCLUDING the high-grade, child subintervals. Considering it in that way ignores the fact that the high-grade intervals are included in the wider, lower-grade intervals, inflating the grade measured over that length. This has enormous implications for the continuity of the mineralization, which determines the feasibility of the project. | . In order to eliminate this effect we&#39;ll need to do some math with the intercepts. This visualization attempts to show this hierarchical, branching structure: . import altair as alt y_axis = alt.Axis( title=&#39;Interval ID&#39;, offset=5, ticks=False, domain=False ) alt.Chart(dh_101).mark_bar().encode( alt.X(&#39;From (m):Q&#39;, scale=alt.Scale(zero=False)), x2=&#39;To (m):Q&#39;, y=alt.Y(&#39;Record:N&#39;, axis=y_axis), color=alt.Color(&#39;Gold (g/t):Q&#39;, scale=alt.Scale(scheme=&quot;inferno&quot;)), tooltip=[ alt.Tooltip(&#39;Width (m):Q&#39;, title=&#39;Width&#39;), alt.Tooltip(&#39;Gold (g/t):Q&#39;, title=&#39;Gold Grade&#39;) ] ).properties(width=800, height=400).configure(background=&#39;#D9E9F0&#39;) . Plotted side by side, the intercepts show the parent-child overlapping relationship and capture the complexity of the problem. . The parent-child relationship can be expressed in a matrix form. . | Imagine . | . !pip install anytree . Collecting anytree Downloading https://files.pythonhosted.org/packages/a8/65/be23d8c3ecd68d40541d49812cd94ed0f3ee37eb88669ca15df0e43daed1/anytree-2.8.0-py2.py3-none-any.whl (41kB) |████████████████████████████████| 51kB 2.8MB/s Requirement already satisfied: six&gt;=1.9.0 in /usr/local/lib/python3.6/dist-packages (from anytree) (1.15.0) Installing collected packages: anytree Successfully installed anytree-2.8.0 . from anytree import Node, RenderTree #nodes = [Node()] . We can use a cool feature of Pandas and convert the From and To fields to intervals . . dh_101[&#39;From (m)&#39;].values . array([108.3 , 120.3 , 127.85, 143. , 169.85, 169.85, 195. , 195.5 , 197. , 211.9 , 211.9 , 211.9 , 212.45, 216. ]) . dh_101[&#39;Interval&#39;] = dh_101.apply(lambda x: pd.Interval(x[&#39;From (m)&#39;], x[&#39;To (m)&#39;]), axis=1) . /usr/local/lib/python3.6/dist-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . dh_101 . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) Record Interval . 398 BR-101 | NaN | 108.30 | 108.80 | 0.50 | 7.47 | 398 | (108.3, 108.8] | . 399 BR-101 | and | 120.30 | 133.00 | 12.70 | 0.51 | 399 | (120.3, 133.0] | . 400 BR-101 | including | 127.85 | 128.85 | 1.00 | 2.42 | 400 | (127.85, 128.85] | . 401 BR-101 | and | 143.00 | 160.00 | 17.00 | 0.17 | 401 | (143.0, 160.0] | . 402 BR-101 | and | 169.85 | 233.10 | 63.25 | 3.61 | 402 | (169.85, 233.1] | . 403 BR-101 | including | 169.85 | 222.00 | 52.15 | 4.24 | 403 | (169.85, 222.0] | . 404 BR-101 | and including | 195.00 | 198.00 | 3.00 | 42.70 | 404 | (195.0, 198.0] | . 405 BR-101 | and including | 195.50 | 197.50 | 2.00 | 61.73 | 405 | (195.5, 197.5] | . 406 BR-101 | and including | 197.00 | 197.50 | 0.50 | 118.00 | 406 | (197.0, 197.5] | . 407 BR-101 | and including | 211.90 | 222.00 | 10.10 | 5.91 | 407 | (211.9, 222.0] | . 408 BR-101 | and including | 211.90 | 221.00 | 9.10 | 6.50 | 408 | (211.9, 221.0] | . 409 BR-101 | and including | 211.90 | 217.00 | 5.10 | 7.68 | 409 | (211.9, 217.0] | . 410 BR-101 | and including | 212.45 | 218.00 | 5.55 | 7.82 | 410 | (212.45, 218.0] | . 411 BR-101 | and including | 216.00 | 218.00 | 2.00 | 8.21 | 411 | (216.0, 218.0] | . Now we can use the pd.Overlaps function . import itertools cross_interval = itertools.product(dh_101.Interval,dh_101.Interval) . import numpy as np #[interval[0].overlaps(interval[1]) for interval in cross_interval] overlap_matrix = np.array([interval[0].overlaps(interval[1]) for interval in cross_interval]) . overlap_matrix.shape . (196,) . overlap_matrix.reshape(14,14) . array([[ True, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, True, True, False, False, False, False, False, False, False, False, False, False, False], [False, True, True, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, True, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, True, True, True, True, True, True, True, True, True, True], [False, False, False, False, True, True, True, True, True, True, True, True, True, True], [False, False, False, False, True, True, True, True, True, False, False, False, False, False], [False, False, False, False, True, True, True, True, True, False, False, False, False, False], [False, False, False, False, True, True, True, True, True, False, False, False, False, False], [False, False, False, False, True, True, False, False, False, True, True, True, True, True], [False, False, False, False, True, True, False, False, False, True, True, True, True, True], [False, False, False, False, True, True, False, False, False, True, True, True, True, True], [False, False, False, False, True, True, False, False, False, True, True, True, True, True], [False, False, False, False, True, True, False, False, False, True, True, True, True, True]]) . overlap_matrix . array([ True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, True, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, True, True, True, True, True, True, True, True, True, True, False, False, False, False, True, True, True, True, True, True, True, True, True, True, False, False, False, False, True, True, True, True, True, False, False, False, False, False, False, False, False, False, True, True, True, True, True, False, False, False, False, False, False, False, False, False, True, True, True, True, True, False, False, False, False, False, False, False, False, False, True, True, False, False, False, True, True, True, True, True, False, False, False, False, True, True, False, False, False, True, True, True, True, True, False, False, False, False, True, True, False, False, False, True, True, True, True, True, False, False, False, False, True, True, False, False, False, True, True, True, True, True, False, False, False, False, True, True, False, False, False, True, True, True, True, True]) . import matplotlib.pyplot as plt plt.rcParams.update({&#39;font.size&#39;: 16}) fig, ax = plt.subplots(1,1, figsize=(10,11)) img = ax.imshow(overlap_matrix.reshape(14,14), cmap=&#39;hot&#39;, interpolation=&#39;nearest&#39;) x_label_list = dh_101.Record.values text = ax.set_xticklabels(x_label_list) text = ax.set_yticklabels(x_label_list) . So we get overlaps, but we do not get contains, which is unfortunate. . Overlap is symmetric: so each &#39;child&#39; overlaps with its parent and . Can get another python package and redo all of this with a different datatype . from sympy import Interval . dh_101[&#39;Interval_obj&#39;] = dh_101.apply(lambda x: Interval(x[&#39;From (m)&#39;], x[&#39;To (m)&#39;]), axis=1) . /usr/local/lib/python3.6/dist-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . cross_interval = itertools.product(dh_101.Interval_obj,dh_101.Interval_obj) contain_matrix = np.array([interval[0].is_proper_superset(interval[1]) for interval in cross_interval]) contain_matrix.reshape(14,14) . array([[False, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, False, True, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, True, True, True, True, True, True, True, True, True], [False, False, False, False, False, False, True, True, True, True, True, True, True, True], [False, False, False, False, False, False, False, True, True, False, False, False, False, False], [False, False, False, False, False, False, False, False, True, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False, True, True, True, True], [False, False, False, False, False, False, False, False, False, False, False, True, True, True], [False, False, False, False, False, False, False, False, False, False, False, False, False, False], [False, False, False, False, False, False, False, False, False, False, False, False, False, True], [False, False, False, False, False, False, False, False, False, False, False, False, False, False]]) . import matplotlib.pyplot as plt plt.rcParams.update({&#39;font.size&#39;: 16}) fig, ax = plt.subplots(1,1, figsize=(10,11)) img = ax.imshow(contain_matrix.reshape(14,14), cmap=&#39;hot&#39;, interpolation=&#39;nearest&#39;) x_label_list = dh_101.Record.values ax.set_xticks(np.arange(0, 14, 1)) ax.set_yticks(np.arange(0, 14, 1)) text = ax.set_xticklabels(x_label_list) text = ax.set_yticklabels(x_label_list) . Now we can pull out a tree . contain_matrix.reshape(14,14).astype(float) . array([[0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1., 1.], [0., 0., 0., 0., 0., 0., 1., 1., 1., 1., 1., 1., 1., 1.], [0., 0., 0., 0., 0., 0., 0., 1., 1., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1., 1.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 1., 1.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.], [0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]]) . for column in contain_matrix.reshape(14,14).astype(float).T: print(column) . [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 1. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 1. 1. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 1. 0. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 1. 1. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 1. 1. 0. 0. 0.] [0. 0. 0. 0. 1. 1. 0. 0. 0. 1. 1. 0. 1. 0.] . contain_matrix.reshape(14,14)[:,0] . array([False, False, False, False, False, False, False, False, False, False, False, False, False, False]) . Of the machine-intelligible formats, a tree data structure is clearly the most suited to representing the intervals. . from anytree import Node, RenderTree, AsciiStyle, PreOrderIter interval_pairs = list(itertools.product(dh_101.Record.values, dh_101.Record.values)) parent_child = list(contain_matrix) root = Node(&quot;BR-101&quot;) all_str_to_node = {str(dh_101[&#39;Record&#39;].values[i]) : Node(str(dh_101[&#39;Record&#39;].values[i]), parent = root) for i, column in enumerate(contain_matrix.reshape(14,14).T)} #[all_str_to_node[str(dh_101[&#39;Record&#39;].values[i])].parent := root for i, column in enumerate(contain_matrix.reshape(14,14).T) if ~np.any(column)] contain_matrix_sq = contain_matrix.reshape(14,14) #for i, col in enumerate(contain_matrix_sq.T): # print(col) # if ~np.any(col): # #all_str_to_node[str(dh_101[&#39;Record&#39;].values[i])].parent = root # print(&quot;Root: {}&quot;.format(dh_101[&#39;Record&#39;].values[i])) # else: # print(&quot;Parent: {}&quot;.format(dh_101[&#39;Record&#39;].values[::-1][np.argmax(col[::-1])])) # print(&quot;Child: {}&quot;.format(dh_101[&#39;Record&#39;].values[i])) . [False False False False False False False False False False False False False False] Root: 398 [False False False False False False False False False False False False False False] Root: 399 [False True False False False False False False False False False False False False] Parent: 399 Child: 400 [False False False False False False False False False False False False False False] Root: 401 [False False False False False False False False False False False False False False] Root: 402 [False False False False True False False False False False False False False False] Parent: 402 Child: 403 [False False False False True True False False False False False False False False] Parent: 403 Child: 404 [False False False False True True True False False False False False False False] Parent: 404 Child: 405 [False False False False True True True True False False False False False False] Parent: 405 Child: 406 [False False False False True True False False False False False False False False] Parent: 403 Child: 407 [False False False False True True False False False True False False False False] Parent: 407 Child: 408 [False False False False True True False False False True True False False False] Parent: 408 Child: 409 [False False False False True True False False False True True False False False] Parent: 408 Child: 410 [False False False False True True False False False True True False True False] Parent: 410 Child: 411 . for i, col in enumerate(contain_matrix_sq.T): if ~np.any(col): all_str_to_node[str(dh_101[&#39;Record&#39;].values[i])].parent = root else: all_str_to_node[str(dh_101[&#39;Record&#39;].values[i])].parent = all_str_to_node[str(dh_101[&#39;Record&#39;].values[::-1][np.argmax(col[::-1])])] . print(RenderTree(root, style=AsciiStyle()).by_attr()) . BR-101 |-- 398 |-- 399 | +-- 400 |-- 401 +-- 402 +-- 403 |-- 404 | +-- 405 | +-- 406 +-- 407 +-- 408 |-- 409 +-- 410 +-- 411 . Now we are really getting somewhere- we can actually start looking at the global picture (since we now know which intervals are not &quot;child&quot; intervals) . dh_101_prime = dh_101[dh_101.Record.isin((child.name for child in root.children))] . These are the direct children. We can go ahead and plot them and have a totally accurate picture of the log: . y_axis = alt.Axis( title=&#39;Intercept ID&#39;, offset=5, ticks=False, domain=False ) reqd_cols = [&#39;From (m)&#39;, &#39;To (m)&#39;, &#39;Gold (g/t)&#39;, &#39;Width (m)&#39;] alt.Chart(dh_101_prime[reqd_cols]).mark_bar().encode( alt.X(&#39;From (m):Q&#39;, scale=alt.Scale(zero=False)), x2=&#39;To (m):Q&#39;, y=alt.Y(&#39;Drill Hole:N&#39;, axis=y_axis), color=alt.Color(&#39;Gold (g/t):Q&#39;, scale=alt.Scale(scheme=&quot;inferno&quot;)), tooltip=[ alt.Tooltip(&#39;Width (m):Q&#39;, title=&#39;Width&#39;), alt.Tooltip(&#39;Gold (g/t):Q&#39;, title=&#39;Gold Grade&#39;) ] ).properties(width=800, height=100).configure(background=&#39;#D9E9F0&#39;) . While that is correct, it is not complete: we have left out all of the additional information provided by the smaller sub-intervals! . In order to incorporate that we will have to remove them from the parent intervals and determine the residual grade (whatever is left once we pull out the gold contained in the subinterval) . from anytree import Node, RenderTree, AsciiStyle, LevelOrderIter #[node.name for node in PostOrderIter(all_str_to_node[&#39;402&#39;])] #[(node.name, node.parent) for node in LevelOrderIter(root)] . ((119) * (3.78) - (3) * (131.5)) / (119 - 3) . As an example of this kind of calculation, a simpler set of intervals from a Freegold Ventures press release: . Freegold Intercepts 3.78 g/t Au Over 119 Metres Including 131.5 g/t Over 3 Metres Within 573 Metres of 1.21 g/t Au at Golden Summit . We know the gold grade over the whole 119 meters, and the gold grade over 3 meters, but what is the gold grade over the $119 - 3 = 116 m$? . The solution is a simple weighted average calculation, like compositing over a drillhole:$ frac{119 times 3.78-3 times 131.5}{119-3} = 0.477 g/t$ . Credit to https://twitter.com/BrentCo77759016/status/1326183861722599424 and . So now we have to do this, but with every single subinterval until we get the residual grade at every point along the drillhole . Fortunately, the tree data structure we selected has specialized methods that make a traversal very simple. . levelord_nodes = [(node.name, node.children) for node in LevelOrderIter(root)] levelord_nodes . [(&#39;BR-101&#39;, (Node(&#39;/BR-101/398&#39;), Node(&#39;/BR-101/399&#39;), Node(&#39;/BR-101/401&#39;), Node(&#39;/BR-101/402&#39;))), (&#39;398&#39;, ()), (&#39;399&#39;, (Node(&#39;/BR-101/399/400&#39;),)), (&#39;401&#39;, ()), (&#39;402&#39;, (Node(&#39;/BR-101/402/403&#39;),)), (&#39;400&#39;, ()), (&#39;403&#39;, (Node(&#39;/BR-101/402/403/404&#39;), Node(&#39;/BR-101/402/403/407&#39;))), (&#39;404&#39;, (Node(&#39;/BR-101/402/403/404/405&#39;),)), (&#39;407&#39;, (Node(&#39;/BR-101/402/403/407/408&#39;),)), (&#39;405&#39;, (Node(&#39;/BR-101/402/403/404/405/406&#39;),)), (&#39;408&#39;, (Node(&#39;/BR-101/402/403/407/408/409&#39;), Node(&#39;/BR-101/402/403/407/408/410&#39;))), (&#39;406&#39;, ()), (&#39;409&#39;, ()), (&#39;410&#39;, (Node(&#39;/BR-101/402/403/407/408/410/411&#39;),)), (&#39;411&#39;, ())] . nn_np_loi = [(node.name, node.parent) for node in LevelOrderIter(root)] . all_str_to_node . {&#39;398&#39;: Node(&#39;/BR-101/398&#39;), &#39;399&#39;: Node(&#39;/BR-101/399&#39;), &#39;400&#39;: Node(&#39;/BR-101/399/400&#39;), &#39;401&#39;: Node(&#39;/BR-101/401&#39;), &#39;402&#39;: Node(&#39;/BR-101/402&#39;), &#39;403&#39;: Node(&#39;/BR-101/402/403&#39;), &#39;404&#39;: Node(&#39;/BR-101/402/403/404&#39;), &#39;405&#39;: Node(&#39;/BR-101/402/403/404/405&#39;), &#39;406&#39;: Node(&#39;/BR-101/402/403/404/405/406&#39;), &#39;407&#39;: Node(&#39;/BR-101/402/403/407&#39;), &#39;408&#39;: Node(&#39;/BR-101/402/403/407/408&#39;), &#39;409&#39;: Node(&#39;/BR-101/402/403/407/408/409&#39;), &#39;410&#39;: Node(&#39;/BR-101/402/403/407/408/410&#39;), &#39;411&#39;: Node(&#39;/BR-101/402/403/407/408/410/411&#39;)} . for node, parent in nn_np_loi[::-1][:-1]: print(node) for child in all_str_to_node[node].children: print(child) . 411 410 Node(&#39;/BR-101/402/403/407/408/410/411&#39;) 409 406 408 Node(&#39;/BR-101/402/403/407/408/409&#39;) Node(&#39;/BR-101/402/403/407/408/410&#39;) 405 Node(&#39;/BR-101/402/403/404/405/406&#39;) 407 Node(&#39;/BR-101/402/403/407/408&#39;) 404 Node(&#39;/BR-101/402/403/404/405&#39;) 403 Node(&#39;/BR-101/402/403/404&#39;) Node(&#39;/BR-101/402/403/407&#39;) 400 402 Node(&#39;/BR-101/402/403&#39;) 401 399 Node(&#39;/BR-101/399/400&#39;) 398 . dh_101 . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) Record Interval Interval_obj . 398 BR-101 | NaN | 108.30 | 108.80 | 0.50 | 7.47 | 398 | (108.3, 108.8] | Interval(108.300000000000, 108.800000000000) | . 399 BR-101 | and | 120.30 | 133.00 | 12.70 | 0.51 | 399 | (120.3, 133.0] | Interval(120.300000000000, 133.000000000000) | . 400 BR-101 | including | 127.85 | 128.85 | 1.00 | 2.42 | 400 | (127.85, 128.85] | Interval(127.850000000000, 128.850000000000) | . 401 BR-101 | and | 143.00 | 160.00 | 17.00 | 0.17 | 401 | (143.0, 160.0] | Interval(143.000000000000, 160.000000000000) | . 402 BR-101 | and | 169.85 | 233.10 | 63.25 | 3.61 | 402 | (169.85, 233.1] | Interval(169.850000000000, 233.100000000000) | . 403 BR-101 | including | 169.85 | 222.00 | 52.15 | 4.24 | 403 | (169.85, 222.0] | Interval(169.850000000000, 222.000000000000) | . 404 BR-101 | and including | 195.00 | 198.00 | 3.00 | 42.70 | 404 | (195.0, 198.0] | Interval(195.000000000000, 198.000000000000) | . 405 BR-101 | and including | 195.50 | 197.50 | 2.00 | 61.73 | 405 | (195.5, 197.5] | Interval(195.500000000000, 197.500000000000) | . 406 BR-101 | and including | 197.00 | 197.50 | 0.50 | 118.00 | 406 | (197.0, 197.5] | Interval(197.000000000000, 197.500000000000) | . 407 BR-101 | and including | 211.90 | 222.00 | 10.10 | 5.91 | 407 | (211.9, 222.0] | Interval(211.900000000000, 222.000000000000) | . 408 BR-101 | and including | 211.90 | 221.00 | 9.10 | 6.50 | 408 | (211.9, 221.0] | Interval(211.900000000000, 221.000000000000) | . 409 BR-101 | and including | 211.90 | 217.00 | 5.10 | 7.68 | 409 | (211.9, 217.0] | Interval(211.900000000000, 217.000000000000) | . 410 BR-101 | and including | 212.45 | 218.00 | 5.55 | 7.82 | 410 | (212.45, 218.0] | Interval(212.450000000000, 218.000000000000) | . 411 BR-101 | and including | 216.00 | 218.00 | 2.00 | 8.21 | 411 | (216.0, 218.0] | Interval(216.000000000000, 218.000000000000) | . dh_101[&#39;grade_len&#39;] = dh_101[&#39;Gold (g/t)&#39;] * dh_101[&#39;Width (m)&#39;] . /usr/local/lib/python3.6/dist-packages/ipykernel_launcher.py:1: SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame. Try using .loc[row_indexer,col_indexer] = value instead See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy &#34;&#34;&#34;Entry point for launching an IPython kernel. . dh_101 . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) Record Interval Interval_obj grade_len . 398 BR-101 | NaN | 108.30 | 108.80 | 0.50 | 7.47 | 398 | (108.3, 108.8] | Interval(108.300000000000, 108.800000000000) | 3.7350 | . 399 BR-101 | and | 120.30 | 133.00 | 12.70 | 0.51 | 399 | (120.3, 133.0] | Interval(120.300000000000, 133.000000000000) | 6.4770 | . 400 BR-101 | including | 127.85 | 128.85 | 1.00 | 2.42 | 400 | (127.85, 128.85] | Interval(127.850000000000, 128.850000000000) | 2.4200 | . 401 BR-101 | and | 143.00 | 160.00 | 17.00 | 0.17 | 401 | (143.0, 160.0] | Interval(143.000000000000, 160.000000000000) | 2.8900 | . 402 BR-101 | and | 169.85 | 233.10 | 63.25 | 3.61 | 402 | (169.85, 233.1] | Interval(169.850000000000, 233.100000000000) | 228.3325 | . 403 BR-101 | including | 169.85 | 222.00 | 52.15 | 4.24 | 403 | (169.85, 222.0] | Interval(169.850000000000, 222.000000000000) | 221.1160 | . 404 BR-101 | and including | 195.00 | 198.00 | 3.00 | 42.70 | 404 | (195.0, 198.0] | Interval(195.000000000000, 198.000000000000) | 128.1000 | . 405 BR-101 | and including | 195.50 | 197.50 | 2.00 | 61.73 | 405 | (195.5, 197.5] | Interval(195.500000000000, 197.500000000000) | 123.4600 | . 406 BR-101 | and including | 197.00 | 197.50 | 0.50 | 118.00 | 406 | (197.0, 197.5] | Interval(197.000000000000, 197.500000000000) | 59.0000 | . 407 BR-101 | and including | 211.90 | 222.00 | 10.10 | 5.91 | 407 | (211.9, 222.0] | Interval(211.900000000000, 222.000000000000) | 59.6910 | . 408 BR-101 | and including | 211.90 | 221.00 | 9.10 | 6.50 | 408 | (211.9, 221.0] | Interval(211.900000000000, 221.000000000000) | 59.1500 | . 409 BR-101 | and including | 211.90 | 217.00 | 5.10 | 7.68 | 409 | (211.9, 217.0] | Interval(211.900000000000, 217.000000000000) | 39.1680 | . 410 BR-101 | and including | 212.45 | 218.00 | 5.55 | 7.82 | 410 | (212.45, 218.0] | Interval(212.450000000000, 218.000000000000) | 43.4010 | . 411 BR-101 | and including | 216.00 | 218.00 | 2.00 | 8.21 | 411 | (216.0, 218.0] | Interval(216.000000000000, 218.000000000000) | 16.4200 | . from sympy import Union import functools for node in levelord_nodes[1:]: parent_interval = dh_101[dh_101[&#39;Record&#39;] == float(node[0])] child_names = [child.name for child in node[1]] child_intervals = [dh_101[dh_101[&#39;Record&#39;] == float(child)] for child in child_names] #print(child_names) l_child_int = [intv[&#39;Interval_obj&#39;].values[0]._measure for intv in child_intervals] print(l_child_int) #g_child_int = [dh_101.loc[int(child_name)][&#39;Gold (g/t)&#39;] for child_name in child_names] lg_child_int = [dh_101.loc[int(child_name)][&#39;grade_len&#39;] for child_name in child_names] #print(parent_interval.grade_len) #print(sum(lg_child_int)) #print(parent_interval[&#39;Width (m)&#39;].values[0]) #print(child_intervals) #resid_grade = (parent_interval.grade_len - sum(lg_child_int)) / (parent_interval[&#39;Width (m)&#39;] - sum(l_child_int)) #print(resid_grade) #try: # print(parent_interval) # print(parent_interval._boundary) # print(parent_interval._measure) #except TypeError: # print(&quot;typeerror&quot;) . [] [1.00000000000000] [] [52.1500000000000] [] [3.00000000000000, 10.1000000000000] [2.00000000000000] [9.09999999999999] [0.500000000000000] [5.09999999999999, 5.55000000000001] [] [] [2.00000000000000] [] . Interval(120.300000000000, 133.000000000000) - Interval(127.850000000000, 128.850000000000) . Union(Interval.Ropen(120.300000000000, 127.850000000000), Interval.Lopen(128.850000000000, 133.000000000000)) . {Interval(120.300000000000, 133.000000000000) : 1, Interval(127.850000000000, 128.850000000000):2} . {Interval(120.300000000000, 133.000000000000): 1, Interval(127.850000000000, 128.850000000000): 2} . dh_101[dh_101.Record == 398] . Drill Hole Unnamed: 1 From (m) To (m) Width (m) Gold (g/t) Record Interval Interval_obj . 398 BR-101 | NaN | 108.3 | 108.8 | 0.5 | 7.47 | 398 | (108.3, 108.8] | Interval(108.300000000000, 108.800000000000) | .",
            "url": "https://nshea3.github.io/blog/2020/12/02/Mathematics-of-Drilling-Intercepts.html",
            "relUrl": "/2020/12/02/Mathematics-of-Drilling-Intercepts.html",
            "date": " • Dec 2, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Simple Betting Strategies in Python",
            "content": ". In mathematics it&#39;s often useful to analyze simple toy strategies and discover their extreme properties. The martingale system (not to be confused with the martingale property) is one such strategy: a simple betting strategy that recommends doubling the value bet with each loss. . It is far from new: . Casanova’s diary, Venice, 1754:Playing the martingale, and doubling my stakescontinuously, I won every day during the remainder of the carnival. [..] I congratulated myself upon having increased the treasure of my dear mistress [..] . Several days later: . I still played on the martingale, but with such bad luck that I was soon left without a sequin. As I shared my property with my mistress, [..] at her request I sold all her diamonds, losing what I got for them; she had now only five hundred sequins by her. There was no more talk of her escaping from the convent, for we had nothing to live on! . Source:Betting systems: how not to lose your moneygambling (G. Berkolaiko) . A fair (50-50, even odds) martingale is a sure thing only with infinite capital to absorb long losing streaks with exponentially increasing losses. An unfair (subfair) game is a loss no matter the betting strategy (there is theoretical work to support this). Subfair games include most casino games (poker excepted - the casino will never let you pick their pocket but picking another punter&#39;s pocket is a matter of supreme indifference). . Roulette is distinguished not only by its . Approaches to roulette reveal bad gamblers (magical thinking and lucky numbers), smart gamblers (bold play on red or black), and smarter gamblers (to be found in the poker room or at a hedge fund). . Roulette, or rather Rou-let&#39;s not . The roulette wheel is likely familiar from any number of appearances in movies and TV. The pockets in the American roulette wheel are labeled with numbers 1 to 36, alternating red and black color. Two special pockets, numbered 0 and 00, are colored green. . . Boil it down to a choice, uniformly at random between the integers 1 to 38, inclusive. (notice that there is a 0 and a 00 that are neither Red nor Black). . The house edge comes from a restriction on the possible bets and unfavorable payouts on the allowed bets. If I had my way, I would walk into the casino and wager all of my money against all of theirs that the outcome is in $ {00, 0, 1, 2, 3, ... , 36 }$ (with probability 1) and be guaranteed a hefty profit. Unfortunately, we can&#39;t do that. We cannot even come close: in American roulette, the best possible bet is any one of the . import numpy as np import matplotlib.pyplot as plt %matplotlib inline . So, if we bet on Black (the closest thing to a fair bet we&#39;ll find in this game), we double our money if the ball lands on Black and lose it all if the ball lands on Red. (a 1:1 payout) . S . Perception that the machine needs to be somehow &quot;rigged&quot; or &quot;fixed&quot; (non-uniform random) to rob the player of their advantage. Not true, the math works out that way for a random choice of, no need for a . We chose the , in fact the closest bet to a fair bet on a roulette wheel is any of the . Playing roulette is not wise because . def get_spin_result(win_prob): result = False if np.random.random() &lt;= win_prob: result = True return result . So we&#39;ve established what happens in a single round of roulette. How to make generalizations about the game . What can we control in this game? . 1) Type of bets 2) Strategy - some sort of strategy that . Type of bets: . Expected value of any single . This is where the martingale strategy comes in: . After every win: Reset the wager $w$ to some base wager $n$ . After every loss: Double the wager to $2w$ . So after some number of losses (let&#39;s say $k$ losses), the next wager will be $n*2^{k}$ . Now we have a (not) new, enticingly simple strategy, the first order of business is to determine the expectation of this strategy in our game. . In pseudocode, our strategy is: . def sim1k(win_prob, n=1000): wl_seq = [get_spin_result(win_prob) for sim in range(n)] winnings = [] win = 0 bet = 1 for wl in wl_seq: if win &lt; 80: if wl == True: win = win + bet bet = 1 else: win = win - bet bet = bet * 2 winnings.append(win) return winnings def sim1k_bankroll(win_prob, n=1000): wl_seq = [get_spin_result(win_prob) for sim in range(n)] winnings = [] win = 0 bet = 1 for wl in wl_seq: if (win &lt; 80 and win &gt; -256): if wl == True: win = win + bet bet = 1 else: win = win - bet bet = min(bet * 2, 256. + win) winnings.append(win) return winnings . win_prob = (18./38.) tentrials = [sim1k(win_prob) for x in range(10)] for trial in tentrials: plt.plot(range(1000), trial) . ktrials = [sim1k(win_prob) for x in range(1000)] #print(sum(np.any(np.array(ktrials) == 80., axis=1)) / len(np.any(np.array(ktrials) == 80., axis=1))) ktmean = np.mean(ktrials, axis = 0) ktsd = np.std(ktrials, axis = 0) for arr in (ktmean, ktmean + ktsd, ktmean - ktsd): plt.plot(range(1000), arr) . ktmed = np.median(ktrials, axis = 0) for arr in (ktmed, ktmed + ktsd, ktmed - ktsd): plt.plot(range(1000), arr) . ktrials_real = [sim1k_bankroll(win_prob) for x in range(1000)] ktmean = np.mean(ktrials_real, axis = 0) ktsd = np.std(ktrials_real, axis = 0) ktmed = np.median(ktrials_real, axis = 0) plt.figure() plt.xlim((0,300)) plt.ylim((-256,100)) for arr in (ktmean, ktmean + ktsd, ktmean - ktsd): plt.plot(range(1000), arr) . for arr in (ktmed, ktmed + ktsd, ktmed - ktsd): plt.plot(range(1000), arr) . Sources . https://www.math.tamu.edu/~berko/teaching/preREU2013/DownloadsForTalk/gambling.pdf . https://people.math.umass.edu/~lr7q/ps_files/teaching/math456/Chapter5.pdf . https://www.fq.math.ca/Scanned/20-3/rabung.pdf . A Statistical Analysis of the Roulette Martingale System: Examples, Formulas and Simulations with R https://digitalscholarship.unlv.edu/gaming_institute/2019/May29/8/ .",
            "url": "https://nshea3.github.io/blog/python/simulation/betting/strategy/martingale/2020/11/20/Simple-Betting-Strategies-Python.html",
            "relUrl": "/python/simulation/betting/strategy/martingale/2020/11/20/Simple-Betting-Strategies-Python.html",
            "date": " • Nov 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nshea3.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://nshea3.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://nshea3.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nshea3.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}